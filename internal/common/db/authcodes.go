// Authentication codes are generated by (at *AuthTable) NewAuthCode() when a new player
// joins the Minecraft server. Players can redeem their authentication code through the
// Discord bot using the "auth" command. This is done through (bot *Bot) cmdAuth().
package db

import (
	"database/sql"
	"github.com/google/uuid"
	"log"
	"strings"
)

type AuthTable struct {
	db   *sql.DB
	fast map[string]string // For quickly storing and getting authentication codes from memory
}

type AuthCode struct {
	AuthCode string // Pending authentication code
	PlayerID string // The Minecraft player associated with the pending code
}

// This will setup the table if it doesn't exist
func GetAuthTable(db *sql.DB) AuthTable {
	_, err := db.Exec(`
CREATE TABLE IF NOT EXISTS auth_codes (
    auth_code TEXT UNIQUE NOT NULL, 
	player_id TEXT PRIMARY KEY NOT NULL)`,
	)

	if err != nil {
		log.Fatalln("Failed to init authentication table\n" + err.Error())
	}
	return AuthTable{
		db:   db,
		fast: map[string]string{},
	}
}

// This will get all the pending authentication codes in the table.
func (at *AuthTable) GetAllAuthCodes() (authCodes []AuthCode) {
	rows, err := at.db.Query(`SELECT * FROM "auth_codes"`)

	if err != nil {
		log.Println("Failed to get all auth codes", err.Error())
		return authCodes
	}

	defer rows.Close()

	for rows.Next() {
		var authCode AuthCode

		err = rows.Scan(&authCode.AuthCode, &authCode.PlayerID)

		if err != nil {
			log.Printf("Failed to scan an account because %s\n", err.Error())
		} else {
			authCodes = append(authCodes, authCode)
		}
	}

	return authCodes
}

// This will create a new authentication code for a given player UUID. If the player
// already has an authentication code then their pending one will be returned instead.
func (at *AuthTable) NewAuthCode(playerID string) (authCode string) {
	// get their pending authentication code if it exists
	oldAuthCode := at.GetAuthCode(playerID)

	if len(oldAuthCode) > 0 {
		return oldAuthCode
	}

	newUUID := uuid.New()
	authCode = strings.Split(newUUID.String(), "-")[0]

	prep, _ := at.db.Prepare(`
INSERT INTO auth_codes (auth_code, player_id) 
VALUES ($1,$2)`,
	)

	_, err := prep.Exec(authCode, playerID)

	defer prep.Close()

	if err != nil {
		log.Printf("Failed to store (%s/%s), because\n%s",
			playerID, authCode, err.Error())
	} else {
		at.fastStore(playerID, authCode)
	}

	return authCode
}

// This will get a pending authentication code of a player UUID. If it doesn't exist
// than an empty string will be returned
func (at *AuthTable) GetAuthCode(playerID string) (authCode string) {
	authCode, isOK := at.fastLoad(playerID)
	if isOK {
		return authCode
	}

	prep, _ := at.db.Prepare(`
SELECT auth_code FROM auth_codes 
WHERE player_id LIKE $1`,
	)
	rows, err := prep.Query(playerID)

	if err != nil {
		return ""
	}

	defer prep.Close()
	defer rows.Close()

	for rows.Next() {
		err = rows.Scan(&authCode)

		if err != nil {
			return ""
		} else {
			at.fastStore(playerID, authCode)
			return authCode
		}
	}
	return ""
}

// Authorize a given authentication code. It will return the player ID associated with the given
// auth code and the returned bool will be false.
func (at *AuthTable) Authorize(authCode string) (playerID string, isOK bool) {
	playerID = at.GetPlayerID(authCode)

	// see if they have an authentication code
	if len(playerID) > 0 {
		isOK = true
		// remove them from the database
		go at.RemoveCode(authCode)
		go at.fastRemove(authCode)

		return playerID, isOK
	} else {
		isOK = false
		return playerID, false
	}
}

// Get the player ID associated with the given authentication code.
func (at *AuthTable) GetPlayerID(authCode string) (playerID string) {
	playerID, isOK := at.fastLoad(authCode)

	if isOK {
		return playerID
	}

	prep, _ := at.db.Prepare(`
SELECT player_id FROM auth_codes 
WHERE auth_code = $1`,
	)
	rows, _ := prep.Query(authCode)
	defer rows.Close()

	for rows.Next() {
		err := rows.Scan(&playerID)

		if err != nil {
			return ""
		} else {
			at.fastStore(playerID, authCode)
			return playerID
		}
	}
	return ""
}

// This will remove an authentication code given. The bool returned represents
// if the authentication code removed was removed.
func (at *AuthTable) RemoveCode(authCode string) bool {
	prep, err := at.db.Prepare(`
DELETE FROM auth_codes 
WHERE auth_code = $1`,
	)
	if err != nil {
		panic(err)
	}

	defer prep.Close()
	result, err := prep.Exec(authCode)

	if err != nil {
		log.Printf(
			"Failed to remove \"%s\", because\n%s",
			authCode,
			err.Error(),
		)
		return false
	} else {
		effected, err := result.RowsAffected()
		if err != nil {
			log.Fatalln(err)
		}
		return effected > 0
	}
}

func (at *AuthTable) fastStore(authCode string, playerID string) {
	at.fast[authCode] = playerID
	at.fast[playerID] = authCode
}

func (at *AuthTable) fastRemove(identifier string) {
	authCode, isOK := at.fast[identifier]
	if isOK {
		delete(at.fast, authCode)
		delete(at.fast, identifier)
	} else {
		playerID, isOK := at.fast[identifier]
		if isOK {
			delete(at.fast, identifier)
			delete(at.fast, playerID)
		}
	}
}

func (at *AuthTable) fastLoad(identifier string) (string, bool) {
	result, isOK := at.fast[identifier]
	return result, isOK
}
